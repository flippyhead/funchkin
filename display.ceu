#include "color.ceu"

native _displayBegin();

#define DISPLAY_PIN 5
#define DISPLAY_NUMPIXELS 16
#define TOP_LED 1
#define LED_OFFSET 0
#define MAX_DISTANCE 2000 // meters; approx. 6 miles (size of BRC city limits) == 9656 meters
#define STEPS 10

input (int) DISPLAY_DIRECTION; // heading
input (int) DISPLAY_DISTANCE; // in meters

native do
  ##include <Adafruit_NeoPixel.h>

  Adafruit_NeoPixel display = Adafruit_NeoPixel(DISPLAY_NUMPIXELS, DISPLAY_PIN, NEO_GRB + NEO_KHZ800);
  int topLED = TOP_LED;
  int compassOffset = LED_OFFSET;

  int lastDir = 16;
  Color dirLED(0, 0, 255);

  // Input a value 0 to 255 to get a color value.
  // The colours are a transition r - g - b - back to r.
  uint32_t Wheel(byte WheelPos) {
    WheelPos = 255 - WheelPos;
    if(WheelPos < 85) {
      return display.Color(255 - WheelPos * 3, 0, WheelPos * 3);
    }
    if(WheelPos < 170) {
      WheelPos -= 85;
      return display.Color(0, WheelPos * 3, 255 - WheelPos * 3);
    }
    WheelPos -= 170;
    return display.Color(WheelPos * 3, 255 - WheelPos * 3, 0);
  }

  void displayBegin() {
    display.begin();
  }

  void displayDirection(int compassHeading) {
    unsigned int ledDir = 2;
    int tempDir = 0;

    if ((compassHeading > 348.75)||(compassHeading < 11.25)) {
        tempDir = topLED;
    }
    for(int i = 1; i < 16; i++){
      float pieSliceCenter = 45/2*i;
      float pieSliceMin = pieSliceCenter - 11.25;
      float pieSliceMax = pieSliceCenter + 11.25;
      if ((compassHeading >= pieSliceMin)&&(compassHeading < pieSliceMax)) {
        tempDir = topLED + i;
      }
    }

    if (tempDir > 15) {
      ledDir = tempDir - 16;
    }

    else if (tempDir < 0) {
      ledDir = tempDir + 16;
    }
    else {
      ledDir = tempDir;
    }

    ledDir = ledDir + compassOffset;
    if (ledDir > 15) {
      ledDir = ledDir - 16;
    }

    if (lastDir != ledDir) {
      display.setPixelColor(lastDir, display.Color(0, 0, 0));
      display.setPixelColor(ledDir, display.Color(dirLED.red, dirLED.green, dirLED.blue));
      display.show();
      lastDir = ledDir;
    }
  }

  int displayDistance(int distance) {
    // Color Farthest(0, 0, 255);  // blue
    // Color Closest(255, 0, 0);  // red

    int shadesPerStep = 255 / STEPS;
    int metersPerStep = MAX_DISTANCE / STEPS;
    int currentStep = distance / metersPerStep;

    if (currentStep > 10) currentStep = 10;

    dirLED.red = 255 - shadesPerStep * currentStep;
    dirLED.green = 0;
    dirLED.blue = shadesPerStep * currentStep;
  }

  void theaterChaseRainbow(uint8_t wait) {
    for (int j=0; j < 6; j++) {
      for (int q=0; q < 3; q++) {
        for (int i=0; i < display.numPixels(); i=i+3) {
          display.setPixelColor(i+q, Wheel( (i+j) % 255));    //turn every third pixel on
        }
        display.show();

        delay(wait);

        for (int i=0; i < display.numPixels(); i=i+3) {
          display.setPixelColor(i+q, 0);        //turn every third pixel off
        }
      }
    }
  }

end

_displayBegin();

par do
  _theaterChaseRainbow(50);
  _displayDirection(1);
with
  loop do
    var int ddirection = await DISPLAY_DIRECTION;
    _displayDirection(ddirection);
  end
with
  loop do
    var int ddistance = await DISPLAY_DISTANCE;
    _displayDistance(ddistance);
  end
end