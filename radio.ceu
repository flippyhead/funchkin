native _radioBegin();

input (int, float, float, int) RADIO_RX; // id, latitude, longitude, heading
input (int, float, float, int) RADIO_TX; // id, latitude, longitude, heading

native do
  ##include <XBee.h>
  #include "lib/SerialCommand.cpp"

  SerialCommand serialCommand;
  XBee xbee = XBee();

  XBeeResponse response = XBeeResponse();
  ZBRxResponse rx = ZBRxResponse();
  ModemStatusResponse msr = ModemStatusResponse();
  ZBTxStatusResponse txStatus = ZBTxStatusResponse();
  XBeeAddress64 addr64 = XBeeAddress64(0x13A200, 0x40A5A01F); // SH + SL Address of receiving XBee

  char rxData[48];
  int rxID, rxHeading;
  float rxLatitude, rxLongitude;

  void radioSendMessage(char message[]) {
    ZBTxRequest zbTx = ZBTxRequest(addr64, (uint8_t *)message, strlen(message));
    xbee.send(zbTx);
  }

  void radioSendMessage(String message, int number) {
    String line = message + " " + number;
    int length = line.length() + 1;
    char buffer[length];
    line.toCharArray(buffer, length);
    radioSendMessage(buffer);
  }

  void xradioSendMessage(char message[], int num, ...) {
    va_list valist;
    char line[100];
    sprintf(line, message, num, valist);
  }

  void radioCommandNotRecognized(const char *command) {
    radioSendMessage("[radio] Command not recognized.");
  }

  void radioCommandUpdateLocation() {
    char *arg, *token;
    arg = serialCommand.next();
    int part = 0;
    float denom = 1000000.0;
    if (arg == NULL) return;

    while ((token = strsep(&arg, ","))) {

      switch (part) {
        case 0:
          rxID = atoi(token);
          break;
        case 1:
          rxLatitude = atol(token) / denom; //(parse_degrees(token) / denom);
          break;
        case 2:
          rxLongitude = atol(token) / denom;
          break;
        case 3:
          rxHeading = atoi(token);
          break;
      }
      part = part + 1;
    }
  }

  void radioBegin() {
    Serial.begin(9600);
    xbee.setSerial(Serial);

    serialCommand.setDefaultHandler(radioCommandNotRecognized);
    serialCommand.addCommand("LOC", radioCommandUpdateLocation);

    radioSendMessage("GPS start.");
  }

  bool radioHasNewData() {
    return xbee.getResponse().isAvailable() &&
      xbee.getResponse().getApiId() == ZB_RX_RESPONSE;
  }

  void radioParseRxPayload(char buffer[]) {
    String inData;
    char received;

    for (int i = 0; i < rx.getDataLength(); i++) {
      received = rx.getData()[i];
      inData += received;
    }

    inData.toCharArray(buffer, rx.getDataLength() + 1);
  }

end

_radioBegin();

par do
  loop do
    _xbee.readPacket();

    if _radioHasNewData() then
      _xbee.getResponse().getZBRxResponse(_rx);

      _radioParseRxPayload(_rxData);
      _serialCommand.readCommand(_rxData);

      _radioSendMessage("[radio] Funchkin received location: ", _rxLatitude);

      async do
        emit RADIO_RX => (_rxID, _rxLatitude, _rxLongitude, _rxHeading);
      end

    else/if _xbee.getResponse().isError() then
      _radioSendMessage("[radio] error reading packet: ", _xbee.getResponse().getErrorCode());
    else
      // nothing / other error
    end

    await 50ms;
  end
with
  loop do
    // if rxId then
    //   emit RADIO_RX => (rxId, latitude, longitude, heading);
    // end

    await 10s;
  end
end