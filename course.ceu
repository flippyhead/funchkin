

native do
  const float pi = 3.14159265358979323846;
  const int radiusOfEarth = 6371.0; // in km
  const float kilometersPerMile = 0.621371192;
  const int tolerance = 15; // degrees

  int calculateDirection(int bearing, int heading) {
    if (heading < bearing) heading += 360;  // denormalize
    int difference = heading - bearing; // calculate left turn, will allways be 0..359

    if (difference > 345 || difference < 15) {
      return 0; // forward
    } else if (difference > 165 && difference < 195) {
      return -2; // behind
    } else if (difference < 180) {
      return 1; // left
    } else {
      return -1; // right
    }
  }

  int calculateBearing(float wayPointLatitude, float wayPointLongitude, float latitude, float longitude) {
    float deltaLongitudeRadians = (wayPointLongitude - longitude)* pi / 180;
    float latitudeRadians = latitude * pi / 180;
    float wayPointLatitudeRadians = wayPointLatitude * pi / 180;

    float y = sin(deltaLongitudeRadians) * cos(wayPointLatitudeRadians);
    float x = cos(latitudeRadians) * sin(wayPointLatitudeRadians) -
      sin(latitudeRadians) * cos(wayPointLatitudeRadians) * cos(deltaLongitudeRadians);

    int bearing = atan2(y, x) / pi * 180;

    if (bearing < 0) {
      bearing = 360 + bearing;
    }

    return bearing;
  }

  float calculateDistance(float wayPointLatitude, float wayPointLongitude, float latitude, float longitude) {
    float deltaLatitudeRadians = (wayPointLatitude - latitude) * pi / 180;
    float deltaLongitudeRadians = (wayPointLongitude - longitude)* pi / 180;

    float latitudeRadians = latitude * pi / 180;
    float wayPointLatitudeRadians = wayPointLatitude * pi / 180;

    float a = sin(deltaLatitudeRadians/2) * sin(deltaLatitudeRadians/2) +
      sin(deltaLongitudeRadians/2) * sin(deltaLongitudeRadians/2) *
      cos(latitudeRadians) * cos(wayPointLatitudeRadians);

    float c = 2 * atan2(sqrt(a), sqrt(1-a));
    float d = radiusOfEarth * c; // distance in kilometers
    return d * kilometersPerMile; // distance in miles
  }

  float scaledDistance(float distance, char unit) {
    switch(unit) {
      case 'M':
        break;
      case 'F':
        distance = distance * 5280;
        break;
    }
    return distance;
  }

end